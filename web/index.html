<!DOCTYPE html>
<html>
<head>
    <title>Sentinel Chip Explorer</title>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <style>
        body { margin: 0; font-family: Arial, sans-serif; }
        #map { height: 100vh; }
        .info-panel {
            position: absolute;
            top: 10px;
            right: 10px;
            width: 320px;
            background: white;
            padding: 15px;
            border-radius: 5px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.3);
            z-index: 1000;
            max-height: 90vh;
            overflow-y: auto;
        }
        .filters {
            margin-bottom: 15px;
            padding: 10px;
            background: #f9f9f9;
            border-radius: 3px;
        }
        .filter-group {
            margin-bottom: 10px;
        }
        .filter-group label {
            display: block;
            font-weight: bold;
            margin-bottom: 3px;
            font-size: 12px;
        }
        .filter-group input, .filter-group select {
            width: 100%;
            padding: 4px;
            border: 1px solid #ccc;
            border-radius: 3px;
            font-size: 12px;
        }
        .filter-buttons {
            display: flex;
            gap: 5px;
        }
        .filter-buttons button {
            flex: 1;
            padding: 6px;
            border: none;
            border-radius: 3px;
            cursor: pointer;
            font-size: 11px;
        }
        .apply-btn { background: #007cba; color: white; }
        .clear-btn { background: #666; color: white; }
        .chip-info {
            margin: 10px 0;
            padding: 10px;
            background: #f5f5f5;
            border-radius: 3px;
        }
        #chip-count {
            font-size: 11px;
            line-height: 1.3;
            margin: 10px 0;
            padding: 8px;
            background: #e8f4f8;
            border-radius: 3px;
            border-left: 3px solid #007cba;
        }
        .loading { color: #666; font-style: italic; }
        .date-slider-container {
            position: relative;
        }
        .multi-range {
            -webkit-appearance: none;
            appearance: none;
            height: 6px;
            background: #ddd;
            border-radius: 3px;
            outline: none;
        }
        .multi-range::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 16px;
            height: 16px;
            background: #007cba;
            border-radius: 50%;
            cursor: pointer;
        }
        .date-labels {
            display: flex;
            justify-content: space-between;
            margin-top: 5px;
            font-size: 12px;
            color: #666;
        }
    </style>
</head>
<body>
    <div id="map"></div>
    <div class="info-panel">
        <h3>Sentinel Chip Explorer</h3>
        
        <div class="filters">
            <div class="filter-group">
                <label>Date Range:</label>
                <div class="date-slider-container">
                    <input type="range" id="date-range" min="0" max="100" value="0,100" class="multi-range">
                    <div class="date-labels">
                        <span id="start-date-label">Loading...</span>
                        <span id="end-date-label">Loading...</span>
                    </div>
                </div>
            </div>
            
            <div class="filter-group">
                <label>Change Score:</label>
                <input type="range" id="min-change" min="0" max="1" step="0.1" value="0">
                <span id="change-value">≥ 0.0</span>
            </div>
            
            <div class="filter-group">
                <label>Scene ID:</label>
                <input type="text" id="scene-filter" placeholder="Filter by scene ID">
            </div>
            
            <div class="filter-group">
                <label>SCL Mean (Cloud Filter):</label>
                <input type="range" id="max-scl" min="0" max="10" step="0.1" value="10">
                <span id="scl-value">≤ 10.0</span>
            </div>
            
            <div class="filter-buttons">
                <button class="apply-btn" onclick="applyFilters()">Apply</button>
                <button class="clear-btn" onclick="clearFilters()">Clear</button>
            </div>
        </div>
        
        <div id="status">Pan and zoom to explore chips</div>
        <div id="chip-count"></div>
        <div id="selected-chip"></div>
    </div>

    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <script>
        // Initialize map
        const map = L.map('map').setView([-10.5, -61.5], 10);
        
        // Add Sentinel-2 base layer (replace with your tile server)
        L.tileLayer('https://mt1.google.com/vt/lyrs=s&x={x}&y={y}&z={z}', {
            attribution: 'Google Satellite',
            maxZoom: 18
        }).addTo(map);
        
        // Layer for chip geometries
        let chipLayer = L.layerGroup().addTo(map);
        
        // OpenSearch configuration
        const OPENSEARCH_URL = 'https://localhost:8443/sentinel/_search';
        const MASTER_USER = 'admin'; // Replace with actual credentials
        const MASTER_PASS = 'S34rch-M3?'; // Replace with actual credentials
        
        // Status elements
        const statusEl = document.getElementById('status');
        const countEl = document.getElementById('chip-count');
        const selectedEl = document.getElementById('selected-chip');
        
        // Filter elements
        const dateRangeEl = document.getElementById('date-range');
        const startDateLabelEl = document.getElementById('start-date-label');
        const endDateLabelEl = document.getElementById('end-date-label');
        const minChangeEl = document.getElementById('min-change');
        const changeValueEl = document.getElementById('change-value');
        const sceneFilterEl = document.getElementById('scene-filter');
        const maxSclEl = document.getElementById('max-scl');
        const sclValueEl = document.getElementById('scl-value');
        
        // Date range state
        let minDate = null;
        let maxDate = null;
        let selectedStartDate = null;
        let selectedEndDate = null;
        
        // Update change score display
        minChangeEl.addEventListener('input', () => {
            changeValueEl.textContent = `≥ ${minChangeEl.value}`;
        });
        
        // Update SCL display
        maxSclEl.addEventListener('input', () => {
            sclValueEl.textContent = `≤ ${maxSclEl.value}`;
        });
        
        // Initialize date range from data
        async function initializeDateRange() {
            try {
                const query = {
                    size: 0,
                    aggs: {
                        date_range: {
                            stats: {
                                field: "@timestamp"
                            }
                        }
                    }
                };
                
                const response = await fetch(OPENSEARCH_URL, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': 'Basic ' + btoa(MASTER_USER + ':' + MASTER_PASS)
                    },
                    body: JSON.stringify(query)
                });
                
                const data = await response.json();
                const stats = data.aggregations.date_range;
                
                minDate = new Date(stats.min);
                maxDate = new Date(stats.max);
                selectedStartDate = minDate;
                selectedEndDate = maxDate;
                
                startDateLabelEl.textContent = minDate.toLocaleDateString();
                endDateLabelEl.textContent = maxDate.toLocaleDateString();
                
                dateRangeEl.min = 0;
                dateRangeEl.max = 100;
                dateRangeEl.value = 0;
                
            } catch (error) {
                console.error('Error getting date range:', error);
                startDateLabelEl.textContent = 'Error';
                endDateLabelEl.textContent = 'Error';
            }
        }
        
        // Handle date range slider
        dateRangeEl.addEventListener('input', () => {
            if (!minDate || !maxDate) return;
            
            const percent = parseFloat(dateRangeEl.value) / 100;
            const totalMs = maxDate.getTime() - minDate.getTime();
            
            selectedStartDate = new Date(minDate.getTime() + (totalMs * percent * 0.8));
            selectedEndDate = new Date(minDate.getTime() + (totalMs * (percent + 0.2)));
            
            if (selectedEndDate > maxDate) selectedEndDate = maxDate;
            
            startDateLabelEl.textContent = selectedStartDate.toLocaleDateString();
            endDateLabelEl.textContent = selectedEndDate.toLocaleDateString();
        });
        
        // Query OpenSearch for chips in current map bounds
        async function queryChips() {
            const bounds = map.getBounds();
            const bbox = [
                bounds.getWest(),
                bounds.getSouth(), 
                bounds.getEast(),
                bounds.getNorth()
            ];
            
            statusEl.textContent = 'Loading chips...';
            statusEl.className = 'loading';
            
            try {
                // Build query filters
                const filters = [{
                    geo_shape: {
                        geometry: {
                            shape: {
                                type: "envelope",
                                coordinates: [[bbox[0], bbox[3]], [bbox[2], bbox[1]]]
                            },
                            relation: "intersects"
                        }
                    }
                }];
                
                // Date range filter
                if (selectedStartDate && selectedEndDate) {
                    filters.push({
                        range: {
                            "@timestamp": {
                                gte: selectedStartDate.getTime(),
                                lte: selectedEndDate.getTime()
                            }
                        }
                    });
                }
                
                // Change score filter
                if (parseFloat(minChangeEl.value) > 0) {
                    filters.push({
                        range: {
                            change_score: {
                                gte: parseFloat(minChangeEl.value)
                            }
                        }
                    });
                }
                
                // Scene ID filter
                if (sceneFilterEl.value.trim()) {
                    filters.push({
                        wildcard: {
                            scene_id: `*${sceneFilterEl.value.trim()}*`
                        }
                    });
                }
                
                // SCL mean filter (cloud filtering)
                if (parseFloat(maxSclEl.value) < 10) {
                    filters.push({
                        range: {
                            scl_mean: {
                                lte: parseFloat(maxSclEl.value)
                            }
                        }
                    });
                }
                
                const query = {
                    size: 10000,
                    query: {
                        bool: {
                            filter: filters
                        }
                    },
                    _source: ["id", "scene_id", "@timestamp", "geohash", "change_score", "geometry"],
                    aggs: {
                        total_chips: { value_count: { field: "id" } },
                        change_stats: { stats: { field: "change_score" } },
                        scl_stats: { stats: { field: "scl_mean" } },
                        scene_count: { cardinality: { field: "scene_id" } },
                        high_change: {
                            filter: { range: { change_score: { gte: 0.5 } } }
                        },
                        clear_chips: {
                            filter: { range: { scl_mean: { lte: 3.0 } } }
                        }
                    }
                };
                
                const response = await fetch(OPENSEARCH_URL, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': 'Basic ' + btoa(MASTER_USER + ':' + MASTER_PASS)
                    },
                    body: JSON.stringify(query)
                });
                
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }
                
                const data = await response.json();
                displayChips(data.hits.hits);
                
                // Display aggregated statistics
                const aggs = data.aggregations;
                const changeStats = aggs.change_stats;
                const sclStats = aggs.scl_stats;
                
                statusEl.textContent = 'Ready';
                statusEl.className = '';
                countEl.innerHTML = `
                    <strong>Dataset Statistics:</strong><br>
                    Total: ${aggs.total_chips.value.toLocaleString()} chips<br>
                    Scenes: ${aggs.scene_count.value} unique<br>
                    Change Score: avg ${changeStats.avg.toFixed(3)}, max ${changeStats.max.toFixed(3)}<br>
                    High Change: ${aggs.high_change.doc_count} chips (≥0.5)<br>
                    Clear Sky: ${aggs.clear_chips.doc_count} chips (SCL≤3.0)<br>
                    SCL Range: ${sclStats.min.toFixed(1)} - ${sclStats.max.toFixed(1)}
                `;
                
            } catch (error) {
                console.error('Error querying chips:', error);
                statusEl.textContent = 'Error loading chips';
                statusEl.className = '';
                countEl.textContent = '';
            }
        }
        
        // Display chip geometries on map
        function displayChips(hits) {
            chipLayer.clearLayers();
            
            hits.forEach(hit => {
                const chip = hit._source;
                const coords = chip.geometry.coordinates[0];
                
                // Convert coordinates to Leaflet format
                const latLngs = coords.map(coord => [coord[1], coord[0]]);
                
                const polygon = L.polygon(latLngs, {
                    color: getChipColor(chip.change_score),
                    weight: 1,
                    fillOpacity: 0.3
                }).addTo(chipLayer);
                
                // Add click handler
                polygon.on('click', () => selectChip(chip));
                
                // Add tooltip
                polygon.bindTooltip(`
                    ID: ${chip.id}<br>
                    Scene: ${chip.scene_id}<br>
                    Change Score: ${chip.change_score.toFixed(3)}<br>
                    Date: ${new Date(chip['@timestamp']).toLocaleDateString()}
                `);
            });
        }
        
        // Color chips based on change score
        function getChipColor(changeScore) {
            if (changeScore > 0.8) return '#ff0000';      // High change - red
            if (changeScore > 0.5) return '#ff8800';      // Medium change - orange  
            if (changeScore > 0.2) return '#ffff00';      // Low change - yellow
            return '#00ff00';                             // No change - green
        }
        
        // Handle chip selection
        function selectChip(chip) {
            selectedEl.innerHTML = `
                <div class="chip-info">
                    <strong>Selected Chip</strong><br>
                    ID: ${chip.id}<br>
                    Scene: ${chip.scene_id}<br>
                    Change Score: ${chip.change_score.toFixed(3)}<br>
                    Date: ${new Date(chip['@timestamp']).toLocaleDateString()}<br>
                    Geohash: ${chip.geohash}<br>
                    <button onclick="findSimilar('${chip.id}')" style="margin-top: 10px; padding: 5px 10px; background: #007cba; color: white; border: none; border-radius: 3px; cursor: pointer;">Find Similar</button>
                </div>
            `;
        }
        
        // Find similar chips using vector similarity
        async function findSimilar(chipId) {
            statusEl.textContent = 'Finding similar chips...';
            statusEl.className = 'loading';
            
            try {
                // First get the embedding for the selected chip
                const getQuery = {
                    query: { term: { id: chipId } },
                    _source: ["embedding"]
                };
                
                const getResponse = await fetch(OPENSEARCH_URL, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': 'Basic ' + btoa(MASTER_USER + ':' + MASTER_PASS)
                    },
                    body: JSON.stringify(getQuery)
                });
                
                const getData = await getResponse.json();
                if (!getData.hits.hits.length) {
                    throw new Error('Chip not found');
                }
                
                const embedding = getData.hits.hits[0]._source.embedding;
                
                // KNN similarity search
                const similarQuery = {
                    size: 50,
                    query: {
                        knn: {
                            embedding: {
                                vector: embedding,
                                k: 50
                            }
                        }
                    },
                    _source: ["id", "scene_id", "@timestamp", "geohash", "change_score", "geometry"]
                };
                
                const similarResponse = await fetch(OPENSEARCH_URL, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': 'Basic ' + btoa(MASTER_USER + ':' + MASTER_PASS)
                    },
                    body: JSON.stringify(similarQuery)
                });
                
                const similarData = await similarResponse.json();
                displayChips(similarData.hits.hits);
                
                statusEl.textContent = 'Showing similar chips';
                statusEl.className = '';
                countEl.textContent = `Found ${similarData.hits.hits.length} similar chips`;
                
            } catch (error) {
                console.error('Error finding similar chips:', error);
                statusEl.textContent = 'Error finding similar chips';
                statusEl.className = '';
            }
        }
        
        // Filter functions
        function applyFilters() {
            queryChips();
        }
        
        function clearFilters() {
            if (minDate && maxDate) {
                selectedStartDate = minDate;
                selectedEndDate = maxDate;
                dateRangeEl.value = 0;
                startDateLabelEl.textContent = minDate.toLocaleDateString();
                endDateLabelEl.textContent = maxDate.toLocaleDateString();
            }
            minChangeEl.value = '0';
            changeValueEl.textContent = '≥ 0.0';
            sceneFilterEl.value = '';
            maxSclEl.value = '10';
            sclValueEl.textContent = '≤ 10.0';
            queryChips();
        }
        
        // Make functions global for onclick handlers
        window.applyFilters = applyFilters;
        window.clearFilters = clearFilters;
        window.findSimilar = findSimilar;
        
        // Query chips when map moves
        map.on('moveend', queryChips);
        
        // Initial load
        initializeDateRange().then(() => {
            queryChips();
        });
    </script>
</body>
</html>